# Имплементация на опашка
Имплементирайте кръгова опашка, базирана на масив в C# – структура от данни, която съдържа елементи и следва принципа 
FIFO (First In, First Out – първи вътре, първи вън), като използвате фиксиран вътрешен капацитет, който се удвоява, когато се запълни.
 
## 1. CircularQueue<T> 
Използвайте следният скелет за класа:
```
public class CircularQueue<T>
{
    private const int DefaultCapacity = 4;
    public int Count { get; private set; }
    public CircularQueue(int capacity = DefaultCapacity) { ... }
    public void Enqueue(T element) { ... }
    public T Dequeue() { ... }
    public T[] ToArray() { ... }
}
```
## 2. Създайте вътрешната информация за опашката
Първата стъпка е да създадете вътрешна информация, която пази елементите, както и началният+крайният индекс:
- T[] elements – масив, който държи елементите на опашката
- Непразните клетки пазят елементите
- Празните клетки са свободни за добавяне на нови елементи
- Дължината на масива (Length) пази капацитета на опашката
- int startIndex – пази началния индекс (индекса на първия влезнал елемент в опашката)
- int endIndex – пази крайния индекс (индекса в масива, който е непосредствено след последния добавен елемент)
- int Count – пази информация за броя елементи в опашката
 
## 3. Направете конструктор
Сега, нека да имплементираме конструктор. Негоава цел е да заделя място за масива в рамките на CircularQueue<T> класа. 
Ще имаме два констуктора:
- Конструктор без параметри – трябва да задели 16 елемента (16 е капацитета по подразбиране в началото за опашката)
- Констуктор с параметър capacity – заделя масива с конкретен капацитет

## 4. Имплементиране на Enqueue(...) метод
Нека да имплементираме Enqueue(element) метода, който добавя нов елемент в края на опашката.

## 5. Имплементиране на Grow() метод
Grow() методът се извиква, когато опашката е със запълнен капацитет (capacity == Count) и искаме да добавим нов елемент. 
Grow() методът трябва да задели нов масив с удвоен капацитет и да премести всички елементи от стария масив в новия масив:
Важна част от "уголемяването" е да се копират елементите от стария масив в новия. 
 
## 6. Имплементиране на Dequeue() метод
Сега е ред на Dequeue() метода. Неговата цел е да се върне и да се премахне от опашката първият добавен елемент 
(той се намира на позиция startIndex). 
 
## 7. Имплементиране на ToArray() Method
Сега нека си направим и ToArray() метод. Той трябва да заделя масив с размер this.Count и да копира всички елементи от опашката в него. 
Ние вече имаме метод за копиране на елементите, така че този път ще се справим по-лесно и кратко. 